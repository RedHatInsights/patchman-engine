-- system_platform
CREATE TABLE IF NOT EXISTS system_platform
(
    id                                   BIGINT GENERATED BY DEFAULT AS IDENTITY,
    inventory_id                         UUID                     NOT NULL,
    rh_account_id                        INT                      NOT NULL,
    vmaas_json                           TEXT                     CHECK (NOT empty(vmaas_json)),
    json_checksum                        TEXT                     CHECK (NOT empty(json_checksum)),
    last_updated                         TIMESTAMP WITH TIME ZONE NOT NULL,
    unchanged_since                      TIMESTAMP WITH TIME ZONE NOT NULL,
    last_evaluation                      TIMESTAMP WITH TIME ZONE,
    installable_advisory_count_cache     INT                      NOT NULL DEFAULT 0,
    installable_advisory_enh_count_cache INT                      NOT NULL DEFAULT 0,
    installable_advisory_bug_count_cache INT                      NOT NULL DEFAULT 0,
    installable_advisory_sec_count_cache INT                      NOT NULL DEFAULT 0,
    last_upload              TIMESTAMP WITH TIME ZONE,
    stale_timestamp          TIMESTAMP WITH TIME ZONE,
    stale_warning_timestamp  TIMESTAMP WITH TIME ZONE,
    culled_timestamp         TIMESTAMP WITH TIME ZONE,
    stale                    BOOLEAN                  NOT NULL DEFAULT false,
    display_name             TEXT                     NOT NULL CHECK (NOT empty(display_name)),
    packages_installed       INT                      NOT NULL DEFAULT 0,
    packages_installable     INT                      NOT NULL DEFAULT 0,
    reporter_id              INT,
    third_party              BOOLEAN                  NOT NULL DEFAULT false,
    yum_updates              JSONB,
    applicable_advisory_count_cache      INT                      NOT NULL DEFAULT 0,
    applicable_advisory_enh_count_cache  INT                      NOT NULL DEFAULT 0,
    applicable_advisory_bug_count_cache  INT                      NOT NULL DEFAULT 0,
    applicable_advisory_sec_count_cache  INT                      NOT NULL DEFAULT 0,
    satellite_managed                    BOOLEAN                  NOT NULL DEFAULT FALSE,
    built_pkgcache                       BOOLEAN                  NOT NULL DEFAULT FALSE,
    packages_applicable      INT                      NOT NULL DEFAULT 0,
    template_id              BIGINT,
    yum_checksum             TEXT                     CHECK (NOT empty(yum_checksum)),
    arch                     TEXT                     CHECK (NOT empty(arch)),
    bootc                    BOOLEAN                  NOT NULL DEFAULT false
) PARTITION BY HASH (rh_account_id);

-- PARTITIONING
SELECT create_table_partitions('system_platform', 16,
                               $$WITH (fillfactor = '70', autovacuum_vacuum_scale_factor = '0.05')
                                 TABLESPACE pg_default$$);

-- PRIVILEGES
GRANT SELECT, INSERT, UPDATE, DELETE ON system_platform TO listener;
-- evaluator needs to update last_evaluation
GRANT UPDATE ON system_platform TO evaluator;
-- manager needs to update cache and delete systems
GRANT SELECT, UPDATE, DELETE ON system_platform TO manager;
-- VMaaS sync needs to be able to perform system culling tasks
GRANT SELECT, UPDATE, DELETE ON system_platform to vmaas_sync;

-- INSERT
INSERT INTO system_platform SELECT
    si.id,
    si.inventory_id,
    si.rh_account_id,
    si.vmaas_json,
    si.json_checksum,
    si.last_updated,
    si.unchanged_since,
    sp.last_evaluation,
    COALESCE(sp.installable_advisory_count_cache, 0),
    COALESCE(sp.installable_advisory_enh_count_cache, 0),
    COALESCE(sp.installable_advisory_bug_count_cache, 0),
    COALESCE(sp.installable_advisory_sec_count_cache, 0),
    si.last_upload,
    si.stale_timestamp,
    si.stale_warning_timestamp,
    si.culled_timestamp,
    si.stale,
    si.display_name,
    COALESCE(sp.packages_installed, 0),
    COALESCE(sp.packages_installable, 0),
    si.reporter_id,
    COALESCE(sp.third_party, false),
    si.yum_updates,
    COALESCE(sp.applicable_advisory_count_cache, 0),
    COALESCE(sp.applicable_advisory_enh_count_cache, 0),
    COALESCE(sp.applicable_advisory_bug_count_cache, 0),
    COALESCE(sp.applicable_advisory_sec_count_cache, 0),
    si.satellite_managed,
    si.built_pkgcache,
    COALESCE(sp.packages_applicable, 0),
    sp.template_id,
    si.yum_checksum,
    si.arch,
    si.bootc
FROM system_inventory si LEFT JOIN system_patch sp
    ON si.rh_account_id = sp.rh_account_id AND si.id = sp.system_id;

SELECT setval('system_platform_id_seq', (SELECT MAX(id) FROM system_platform));

-- TRIGGERS
SELECT create_table_partition_triggers('system_platform_set_last_updated',
                                       $$BEFORE INSERT OR UPDATE$$,
                                       'system_platform',
                                       $$FOR EACH ROW EXECUTE PROCEDURE set_last_updated()$$);

SELECT create_table_partition_triggers('system_platform_check_unchanged',
                                       $$BEFORE INSERT OR UPDATE$$,
                                       'system_platform',
                                       $$FOR EACH ROW EXECUTE PROCEDURE check_unchanged()$$);

SELECT create_table_partition_triggers('system_platform_on_update',
                                       $$AFTER UPDATE$$,
                                       'system_platform',
                                       $$FOR EACH ROW EXECUTE PROCEDURE on_system_update()$$);

-- CONSTRAINTS
ALTER TABLE system_platform
ADD PRIMARY KEY (rh_account_id, id),
ADD FOREIGN KEY (reporter_id) REFERENCES reporter (id),
ADD FOREIGN KEY (rh_account_id, template_id) REFERENCES template (rh_account_id, id),
ADD FOREIGN KEY (rh_account_id) REFERENCES rh_account (id),
ADD UNIQUE (rh_account_id, inventory_id);

-- INDEXES
CREATE INDEX IF NOT EXISTS system_platform_inventory_id_idx
    ON system_platform (inventory_id);

-- UPDATE FUNCTIONS
CREATE OR REPLACE FUNCTION on_system_update()
-- this trigger updates advisory_account_data when server changes its stale flag
    RETURNS TRIGGER
AS
$system_update$
DECLARE
    was_counted  BOOLEAN;
    should_count BOOLEAN;
    change       INT;
BEGIN
    -- Ignore not yet evaluated systems
    IF TG_OP != 'UPDATE' OR NEW.last_evaluation IS NULL THEN
        RETURN NEW;
    END IF;

    was_counted := OLD.stale = FALSE;
    should_count := NEW.stale = FALSE;

    -- Determine what change we are performing
    IF was_counted and NOT should_count THEN
        change := -1;
    ELSIF NOT was_counted AND should_count THEN
        change := 1;
    ELSE
        -- No change
        RETURN NEW;
    END IF;

    -- insert/update advisories linked to the server
    INSERT
      INTO advisory_account_data (advisory_id, rh_account_id, systems_installable, systems_applicable)
    SELECT sa.advisory_id, NEW.rh_account_id,
           case when sa.status_id = 0 then change else 0 end as systems_installable,
           change as systems_applicable
      FROM system_advisories sa
     WHERE sa.system_id = NEW.id AND sa.rh_account_id = NEW.rh_account_id
     ORDER BY sa.advisory_id
        ON CONFLICT (advisory_id, rh_account_id) DO UPDATE
           SET systems_installable = advisory_account_data.systems_installable + EXCLUDED.systems_installable,
               systems_applicable = advisory_account_data.systems_applicable + EXCLUDED.systems_applicable;
    RETURN NEW;
END;
$system_update$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION refresh_advisory_caches_multi(advisory_ids_in INTEGER[] DEFAULT NULL,
                                                         rh_account_id_in INTEGER DEFAULT NULL)
    RETURNS VOID AS
$refresh_advisory$
BEGIN
    -- Lock rows
    PERFORM aad.rh_account_id, aad.advisory_id
    FROM advisory_account_data aad
    WHERE (aad.advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
      AND (aad.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
        FOR UPDATE OF aad;

    WITH current_counts AS (
        SELECT sa.advisory_id, sa.rh_account_id,
               count(sa.*) filter (where sa.status_id = 0) as systems_installable,
               count(sa.*) as systems_applicable
          FROM system_advisories sa
          JOIN system_platform sp
            ON sa.rh_account_id = sp.rh_account_id AND sa.system_id = sp.id
         WHERE sp.last_evaluation IS NOT NULL
           AND sp.stale = FALSE
           AND (sa.advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
           AND (sp.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
         GROUP BY sa.advisory_id, sa.rh_account_id
    ),
        upserted AS (
            INSERT INTO advisory_account_data (advisory_id, rh_account_id, systems_installable, systems_applicable)
                 SELECT advisory_id, rh_account_id, systems_installable, systems_applicable
                   FROM current_counts
            ON CONFLICT (advisory_id, rh_account_id) DO UPDATE SET
                     systems_installable = EXCLUDED.systems_installable,
                     systems_applicable = EXCLUDED.systems_applicable
         )
    DELETE FROM advisory_account_data
     WHERE (advisory_id, rh_account_id) NOT IN (SELECT advisory_id, rh_account_id FROM current_counts)
       AND (advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
       AND (rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL);
END;
$refresh_advisory$ language plpgsql;

CREATE OR REPLACE FUNCTION refresh_system_caches(system_id_in BIGINT DEFAULT NULL,
                                                 rh_account_id_in INTEGER DEFAULT NULL)
    RETURNS INTEGER AS
$refresh_system$
DECLARE
    COUNT INTEGER;
BEGIN
    WITH system_advisories_count AS (
        SELECT asp.rh_account_id, asp.id,
               COUNT(advisory_id) FILTER (WHERE sa.status_id = 0) as installable_total,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 1 AND sa.status_id = 0) AS installable_enhancement,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 2 AND sa.status_id = 0) AS installable_bugfix,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 3 AND sa.status_id = 0) as installable_security,
               COUNT(advisory_id) as applicable_total,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 1) AS applicable_enhancement,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 2) AS applicable_bugfix,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 3) as applicable_security
          FROM system_platform asp  -- this table ensures even systems without any system_advisories are in results
          LEFT JOIN system_advisories sa
            ON asp.rh_account_id = sa.rh_account_id AND asp.id = sa.system_id
          LEFT JOIN advisory_metadata am
            ON sa.advisory_id = am.id
         WHERE (asp.id = system_id_in OR system_id_in IS NULL)
           AND (asp.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
         GROUP BY asp.rh_account_id, asp.id
         ORDER BY asp.rh_account_id, asp.id
    )
        UPDATE system_platform sp
           SET installable_advisory_count_cache = sc.installable_total,
               installable_advisory_enh_count_cache = sc.installable_enhancement,
               installable_advisory_bug_count_cache = sc.installable_bugfix,
               installable_advisory_sec_count_cache = sc.installable_security,
               applicable_advisory_count_cache = sc.applicable_total,
               applicable_advisory_enh_count_cache = sc.applicable_enhancement,
               applicable_advisory_bug_count_cache = sc.applicable_bugfix,
               applicable_advisory_sec_count_cache = sc.applicable_security
          FROM system_advisories_count sc
         WHERE sp.rh_account_id = sc.rh_account_id AND sp.id = sc.id
           AND (sp.id = system_id_in OR system_id_in IS NULL)
           AND (sp.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL);

    GET DIAGNOSTICS COUNT = ROW_COUNT;
    RETURN COUNT;
END;
$refresh_system$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
    RETURNS void AS
$refresh_system_cached_counts$
DECLARE
    system_id int;
BEGIN

    SELECT id FROM system_platform WHERE inventory_id = inventory_id_in INTO system_id;

    PERFORM refresh_system_caches(system_id, NULL);
END;
$refresh_system_cached_counts$
    LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION delete_system(inventory_id_in uuid)
    RETURNS TABLE
            (
                deleted_inventory_id uuid
            )
AS
$delete_system$
DECLARE
    v_system_id  INT;
    v_account_id INT;
BEGIN
    -- opt out to refresh cache and then delete
    SELECT id, rh_account_id
    FROM system_platform
    WHERE inventory_id = inventory_id_in
    LIMIT 1
        FOR UPDATE OF system_platform
    INTO v_system_id, v_account_id;

    IF v_system_id IS NULL OR v_account_id IS NULL THEN
        RAISE NOTICE 'Not found';
        RETURN;
    END IF;

    UPDATE system_platform
    SET stale = true
    WHERE rh_account_id = v_account_id
      AND id = v_system_id;

    DELETE
    FROM system_advisories
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    DELETE
    FROM system_repo
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    DELETE
    FROM system_package2
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    RETURN QUERY DELETE FROM system_platform
        WHERE rh_account_id = v_account_id AND
              id = v_system_id
        RETURNING inventory_id;
END;
$delete_system$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION delete_systems(inventory_ids UUID[])
    RETURNS INTEGER
AS
$$
DECLARE
    tmp_cnt INTEGER;
BEGIN

    WITH systems as (
        SELECT rh_account_id, id
        FROM system_platform
        WHERE inventory_id = ANY (inventory_ids)
        ORDER BY rh_account_id, id FOR UPDATE OF system_platform),
         marked as (
             UPDATE system_platform sp
                 SET stale = true
                 WHERE (rh_account_id, id) in (select rh_account_id, id from systems)
         ),
         advisories as (
             DELETE
                 FROM system_advisories
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         repos as (
             DELETE
                 FROM system_repo
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         packages2 as (
             DELETE
                 FROM system_package2
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         deleted as (
             DELETE
                 FROM system_platform
                     WHERE (rh_account_id, id) in (select rh_account_id, id from systems)
                     RETURNING id
         )
    SELECT count(*)
    FROM deleted
    INTO tmp_cnt;

    RETURN tmp_cnt;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION delete_culled_systems(delete_limit INTEGER)
    RETURNS INTEGER
AS
$$
DECLARE
    ids UUID[];
BEGIN
    ids := ARRAY(
            SELECT inventory_id
            FROM system_platform
            WHERE culled_timestamp < now()
            ORDER BY id
            LIMIT delete_limit
        );
    return delete_systems(ids);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION mark_stale_systems(mark_limit integer)
    RETURNS INTEGER
AS
$$
DECLARE
    marked integer;
BEGIN
    WITH ids AS (
        SELECT rh_account_id, id
        FROM system_platform
        WHERE stale_warning_timestamp < now()
          AND stale = false
        ORDER BY rh_account_id, id FOR UPDATE OF system_platform
        LIMIT mark_limit
    )
    UPDATE system_platform sp
    SET stale = true
    FROM ids
    WHERE sp.rh_account_id = ids.rh_account_id
      AND sp.id = ids.id;
    GET DIAGNOSTICS marked = ROW_COUNT;
    RETURN marked;
END;
$$ LANGUAGE plpgsql;

-- inventory.hosts gets created by cyndi
