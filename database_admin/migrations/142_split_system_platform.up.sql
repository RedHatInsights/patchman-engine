-- system_inventory
CREATE TABLE IF NOT EXISTS system_inventory
(
    id                                  BIGINT GENERATED BY DEFAULT AS IDENTITY,
    inventory_id                        UUID        NOT NULL,
    rh_account_id                       INT         NOT NULL,
    vmaas_json                          TEXT        CHECK (NOT empty(vmaas_json)),
    json_checksum                       TEXT        CHECK (NOT empty(json_checksum)),
    last_updated                        TIMESTAMPTZ NOT NULL,
    unchanged_since                     TIMESTAMPTZ NOT NULL,
    last_upload                         TIMESTAMPTZ,
    stale                               BOOLEAN     NOT NULL DEFAULT false,
    display_name                        TEXT        NOT NULL CHECK (NOT empty(display_name)),
    reporter_id                         INT,
    yum_updates                         JSONB,
    yum_checksum                        TEXT        CHECK (NOT empty(yum_checksum)),
    satellite_managed                   BOOLEAN     NOT NULL DEFAULT false,
    built_pkgcache                      BOOLEAN     NOT NULL DEFAULT false,
    arch                                TEXT        CHECK (NOT empty(arch)),
    bootc                               BOOLEAN     NOT NULL DEFAULT false,
    tags                                JSONB       NOT NULL,
    created                             TIMESTAMPTZ NOT NULL,
    workspaces                          TEXT ARRAY  CHECK (array_length(workspaces,1) > 0 or workspaces is null), -- group IDs from system_platform.groups
    stale_timestamp                     TIMESTAMPTZ,
    stale_warning_timestamp             TIMESTAMPTZ,
    culled_timestamp                    TIMESTAMPTZ,
    os_name                             TEXT        CHECK (NOT empty(os_name)),
    os_major                            SMALLINT,
    os_minor                            SMALLINT,
    rhsm_version                        TEXT        CHECK (NOT empty(rhsm_version)),
    subscription_manager_id             UUID,
    sap_workload                        BOOLEAN     NOT NULL DEFAULT false,
    sap_workload_sids                   TEXT ARRAY  CHECK (array_length(sap_workload_sids,1) > 0 or sap_workload_sids is null),
    ansible_workload                    BOOLEAN     NOT NULL DEFAULT false,
    ansible_workload_controller_version TEXT        CHECK (NOT empty(ansible_workload_controller_version)),
    mssql_workload                      BOOLEAN     NOT NULL DEFAULT false,
    mssql_workload_version              TEXT        CHECK (NOT empty(mssql_workload_version))
) PARTITION BY HASH (rh_account_id);

-- PARTITIONING
SELECT create_table_partitions('system_inventory', 16,
                               $$WITH (fillfactor = '70', autovacuum_vacuum_scale_factor = '0.05')
                                 TABLESPACE pg_default$$);

-- PRIVILEGES (listener has write access)
GRANT SELECT, INSERT, UPDATE ON system_inventory TO listener;
GRANT SELECT, UPDATE, DELETE ON system_inventory TO vmaas_sync; -- vmaas_sync performs system culling
GRANT SELECT, UPDATE (stale) ON system_inventory TO manager; -- manager needs to be able to update opt_out column
GRANT SELECT, UPDATE ON system_inventory TO evaluator;
SELECT grant_table_partitions('SELECT', 'system_inventory', 'evaluator');
SELECT grant_table_partitions('SELECT', 'system_inventory', 'listener');
SELECT grant_table_partitions('SELECT', 'system_inventory', 'manager');
SELECT grant_table_partitions('SELECT', 'system_inventory', 'vmaas_sync');
GRANT SELECT, USAGE ON SEQUENCE system_inventory_id_seq TO evaluator;
GRANT SELECT, USAGE ON SEQUENCE system_inventory_id_seq TO listener;
GRANT SELECT, USAGE ON SEQUENCE system_inventory_id_seq TO vmaas_sync;

do $$ begin RAISE NOTICE 'Created system_inventory'; end $$;

-- LOAD DATA
INSERT INTO system_inventory (
    id,
    inventory_id,
    rh_account_id,
    vmaas_json,
    json_checksum,
    last_updated,
    unchanged_since,
    last_upload,
    stale,
    display_name,
    reporter_id,
    yum_updates,
    yum_checksum,
    satellite_managed,
    built_pkgcache,
    arch,
    bootc,
    tags,
    created,
    stale_timestamp,
    stale_warning_timestamp,
    culled_timestamp
  )
  SELECT
    id,
    inventory_id,
    rh_account_id,
    vmaas_json,
    json_checksum,
    last_updated,
    unchanged_since,
    last_upload,
    stale,
    display_name,
    reporter_id,
    yum_updates,
    yum_checksum,
    satellite_managed,
    built_pkgcache,
    arch,
    bootc,
    '[]',
    CURRENT_TIMESTAMP,
    stale_timestamp,
    stale_warning_timestamp,
    culled_timestamp
FROM system_platform sp;

SELECT setval('system_inventory_id_seq', (SELECT MAX(id) FROM system_inventory));

CREATE OR REPLACE FUNCTION safe_to_int(input_text TEXT)
RETURNS SMALLINT AS $$
BEGIN
  RETURN input_text::SMALLINT;
EXCEPTION WHEN OTHERS THEN
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION safe_to_uuid(input_text TEXT)
RETURNS UUID AS $$
BEGIN
  RETURN input_text::UUID;
EXCEPTION WHEN OTHERS THEN
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DO $$ 
BEGIN 
    IF EXISTS (SELECT FROM pg_tables WHERE schemaname = 'inventory' AND tablename = 'hosts') THEN
        UPDATE system_inventory si
        SET
          tags = ih.tags,
          created = ih.created,
          workspaces = ARRAY(SELECT jsonb_array_elements(ih.groups)->>'id'),
          os_name = ih.system_profile->'operating_system'->>'name',
          os_major = safe_to_int(ih.system_profile->'operating_system'->>'major'),
          os_minor = safe_to_int(ih.system_profile->'operating_system'->>'minor'),
          rhsm_version = NULLIF(ih.system_profile->'rhsm'->>'version', ''),
          subscription_manager_id = safe_to_uuid(ih.system_profile->>'owner_id'),
          sap_workload = COALESCE((ih.system_profile->'workloads'->'sap'->>'sap_system')::BOOLEAN, false),
          sap_workload_sids = ARRAY(SELECT jsonb_array_elements_text(ih.system_profile->'workloads'->'sap'->'sids')),
          ansible_workload = COALESCE(LENGTH(ih.system_profile->'workloads'->>'ansible') > 2, false),
          ansible_workload_controller_version = NULLIF(ih.system_profile->'workloads'->'ansible'->>'controller_version', ''),
          mssql_workload = COALESCE(LENGTH(ih.system_profile->'workloads'->>'mssql') > 2, false),
          mssql_workload_version = NULLIF(ih.system_profile->'workloads'->'mssql'->>'version', '')
        FROM inventory.hosts ih
        WHERE ih.id = si.inventory_id;
    END IF;
END $$;

DROP FUNCTION safe_to_int;
DROP FUNCTION safe_to_uuid;

do $$ begin RAISE NOTICE 'Data loaded into system_inventory'; end $$;

-- TRIGGERS
SELECT create_table_partition_triggers('system_inventory_set_last_updated',
                                       $$BEFORE INSERT OR UPDATE$$,
                                       'system_inventory',
                                       $$FOR EACH ROW EXECUTE PROCEDURE set_last_updated()$$);

SELECT create_table_partition_triggers('system_inventory_check_unchanged',
                                       $$BEFORE INSERT OR UPDATE$$,
                                       'system_inventory',
                                       $$FOR EACH ROW EXECUTE PROCEDURE check_unchanged()$$);

SELECT create_table_partition_triggers('system_inventory_on_update',
                                       $$AFTER UPDATE$$,
                                       'system_inventory',
                                       $$FOR EACH ROW EXECUTE PROCEDURE on_system_update()$$);

-- CONSTRAINTS
ALTER TABLE IF EXISTS system_inventory
ADD PRIMARY KEY (rh_account_id, id),
ADD FOREIGN KEY (rh_account_id) REFERENCES rh_account (id),
ADD FOREIGN KEY (reporter_id) REFERENCES reporter (id),
ADD UNIQUE (rh_account_id, inventory_id);

-- INDEXES
CREATE INDEX IF NOT EXISTS system_inventory_inventory_id_idx ON system_inventory (inventory_id);
CREATE INDEX IF NOT EXISTS system_inventory_tags_index ON system_inventory USING GIN (tags JSONB_PATH_OPS);
CREATE INDEX IF NOT EXISTS system_inventory_stale_timestamp_index ON system_inventory (stale_timestamp);
CREATE INDEX IF NOT EXISTS system_inventory_workspaces_index ON system_inventory USING GIN (workspaces);

do $$ begin RAISE NOTICE 'Added triggers, constraints, and indexes to system_inventory'; end $$;

-- UPDATE FKEYS
ALTER TABLE IF EXISTS system_repo
DROP CONSTRAINT system_platform_id,
ADD CONSTRAINT system_inventory_id
    FOREIGN KEY (rh_account_id, system_id)
    REFERENCES system_inventory (rh_account_id, id);

ALTER TABLE IF EXISTS system_advisories
DROP CONSTRAINT system_platform_id,
ADD CONSTRAINT system_inventory_id
    FOREIGN KEY (rh_account_id, system_id)
    REFERENCES system_inventory (rh_account_id, id);

ALTER TABLE IF EXISTS system_package2
DROP CONSTRAINT system_package2_rh_account_id_system_id_fkey,
ADD CONSTRAINT system_inventory_id
    FOREIGN KEY (rh_account_id, system_id)
    REFERENCES system_inventory (rh_account_id, id);

do $$ begin RAISE NOTICE 'Updated fkey references from system_platform to system_inventory'; end $$;

-- UPDATE FUNCTIONS
CREATE OR REPLACE FUNCTION on_system_update()
-- this trigger updates advisory_account_data when server changes its stale flag
    RETURNS TRIGGER
AS
$system_update$
DECLARE
    was_counted  BOOLEAN;
    should_count BOOLEAN;
    change       INT;
BEGIN
    -- Ignore not yet evaluated systems
    IF TG_OP != 'UPDATE' OR NOT EXISTS (
        SELECT 1
        FROM system_patch
        WHERE system_id = NEW.id 
          AND rh_account_id = NEW.rh_account_id
          AND last_evaluation IS NOT NULL
    ) THEN
        RETURN NEW;
    END IF;

    was_counted := OLD.stale = FALSE;
    should_count := NEW.stale = FALSE;

    -- Determine what change we are performing
    IF was_counted and NOT should_count THEN
        change := -1;
    ELSIF NOT was_counted AND should_count THEN
        change := 1;
    ELSE
        -- No change
        RETURN NEW;
    END IF;

    -- insert/update advisories linked to the server
    INSERT
      INTO advisory_account_data (advisory_id, rh_account_id, systems_installable, systems_applicable)
    SELECT sa.advisory_id, NEW.rh_account_id,
           case when sa.status_id = 0 then change else 0 end as systems_installable,
           change as systems_applicable
      FROM system_advisories sa
     WHERE sa.system_id = NEW.id AND sa.rh_account_id = NEW.rh_account_id
     ORDER BY sa.advisory_id
        ON CONFLICT (advisory_id, rh_account_id) DO UPDATE
           SET systems_installable = advisory_account_data.systems_installable + EXCLUDED.systems_installable,
               systems_applicable = advisory_account_data.systems_applicable + EXCLUDED.systems_applicable;
    RETURN NEW;
END;
$system_update$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION refresh_advisory_caches_multi(advisory_ids_in INTEGER[] DEFAULT NULL,
                                                         rh_account_id_in INTEGER DEFAULT NULL)
    RETURNS VOID AS
$refresh_advisory$
BEGIN
    -- Lock rows
    PERFORM aad.rh_account_id, aad.advisory_id
    FROM advisory_account_data aad
    WHERE (aad.advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
      AND (aad.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
        FOR UPDATE OF aad;

    WITH current_counts AS (
        SELECT sa.advisory_id, sa.rh_account_id,
               count(sa.*) filter (where sa.status_id = 0) as systems_installable,
               count(sa.*) as systems_applicable
          FROM system_advisories sa
          JOIN system_inventory si
            ON sa.rh_account_id = si.rh_account_id AND sa.system_id = si.id
          JOIN system_patch sp
            ON si.id = sp.system_id AND sp.rh_account_id = si.rh_account_id
         WHERE sp.last_evaluation IS NOT NULL
           AND si.stale = FALSE
           AND (sa.advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
           AND (si.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
         GROUP BY sa.advisory_id, sa.rh_account_id
    ),
        upserted AS (
            INSERT INTO advisory_account_data (advisory_id, rh_account_id, systems_installable, systems_applicable)
                 SELECT advisory_id, rh_account_id, systems_installable, systems_applicable
                   FROM current_counts
            ON CONFLICT (advisory_id, rh_account_id) DO UPDATE SET
                     systems_installable = EXCLUDED.systems_installable,
                     systems_applicable = EXCLUDED.systems_applicable
         )
    DELETE FROM advisory_account_data
     WHERE (advisory_id, rh_account_id) NOT IN (SELECT advisory_id, rh_account_id FROM current_counts)
       AND (advisory_id = ANY (advisory_ids_in) OR advisory_ids_in IS NULL)
       AND (rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL);
END;
$refresh_advisory$ language plpgsql;

CREATE OR REPLACE FUNCTION refresh_system_caches(system_id_in BIGINT DEFAULT NULL,
                                                 rh_account_id_in INTEGER DEFAULT NULL)
    RETURNS INTEGER AS
$refresh_system$
DECLARE
    COUNT INTEGER;
BEGIN
    WITH system_advisories_count AS (
        SELECT si.rh_account_id, si.id,
               COUNT(advisory_id) FILTER (WHERE sa.status_id = 0) as installable_total,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 1 AND sa.status_id = 0) AS installable_enhancement,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 2 AND sa.status_id = 0) AS installable_bugfix,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 3 AND sa.status_id = 0) as installable_security,
               COUNT(advisory_id) as applicable_total,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 1) AS applicable_enhancement,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 2) AS applicable_bugfix,
               COUNT(advisory_id) FILTER (WHERE am.advisory_type_id = 3) as applicable_security
          FROM system_inventory si  -- this table ensures even systems without any system_advisories are in results
          LEFT JOIN system_advisories sa
            ON si.rh_account_id = sa.rh_account_id AND si.id = sa.system_id
          LEFT JOIN advisory_metadata am
            ON sa.advisory_id = am.id
         WHERE (si.id = system_id_in OR system_id_in IS NULL)
           AND (si.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL)
         GROUP BY si.rh_account_id, si.id
         ORDER BY si.rh_account_id, si.id
    )
        UPDATE system_patch sp
           SET installable_advisory_count_cache = sc.installable_total,
               installable_advisory_enh_count_cache = sc.installable_enhancement,
               installable_advisory_bug_count_cache = sc.installable_bugfix,
               installable_advisory_sec_count_cache = sc.installable_security,
               applicable_advisory_count_cache = sc.applicable_total,
               applicable_advisory_enh_count_cache = sc.applicable_enhancement,
               applicable_advisory_bug_count_cache = sc.applicable_bugfix,
               applicable_advisory_sec_count_cache = sc.applicable_security
          FROM system_advisories_count sc
         WHERE sp.rh_account_id = sc.rh_account_id AND sp.system_id = sc.id
           AND (sp.system_id = system_id_in OR system_id_in IS NULL)
           AND (sp.rh_account_id = rh_account_id_in OR rh_account_id_in IS NULL);

    GET DIAGNOSTICS COUNT = ROW_COUNT;
    RETURN COUNT;
END;
$refresh_system$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION refresh_system_cached_counts(inventory_id_in varchar)
    RETURNS void AS
$refresh_system_cached_counts$
DECLARE
    system_id int;
BEGIN

    SELECT id FROM system_inventory WHERE inventory_id = inventory_id_in INTO system_id;

    PERFORM refresh_system_caches(system_id, NULL);
END;
$refresh_system_cached_counts$
    LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION delete_system(inventory_id_in uuid)
    RETURNS TABLE
            (
                deleted_inventory_id uuid
            )
AS
$delete_system$
DECLARE
    v_system_id  INT;
    v_account_id INT;
BEGIN
    -- opt out to refresh cache and then delete
    SELECT id, rh_account_id
    FROM system_inventory
    WHERE inventory_id = inventory_id_in
    LIMIT 1
        FOR UPDATE OF system_inventory
    INTO v_system_id, v_account_id;

    IF v_system_id IS NULL OR v_account_id IS NULL THEN
        RAISE NOTICE 'Not found';
        RETURN;
    END IF;

    UPDATE system_inventory
    SET stale = true
    WHERE rh_account_id = v_account_id
      AND id = v_system_id;

    DELETE
    FROM system_advisories
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    DELETE
    FROM system_repo
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    DELETE
    FROM system_package2
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    DELETE
    FROM system_patch
    WHERE rh_account_id = v_account_id
      AND system_id = v_system_id;

    RETURN QUERY DELETE FROM system_inventory
        WHERE rh_account_id = v_account_id AND
              id = v_system_id
        RETURNING inventory_id;
END;
$delete_system$ LANGUAGE 'plpgsql';

CREATE OR REPLACE FUNCTION delete_systems(inventory_ids UUID[])
    RETURNS INTEGER
AS
$$
DECLARE
    tmp_cnt INTEGER;
BEGIN

    WITH systems as (
        SELECT rh_account_id, id
        FROM system_inventory
        WHERE inventory_id = ANY (inventory_ids)
        ORDER BY rh_account_id, id FOR UPDATE OF system_inventory),
         marked as (
             UPDATE system_inventory sp
                 SET stale = true
                 WHERE (rh_account_id, id) in (select rh_account_id, id from systems)
         ),
         advisories as (
             DELETE
                 FROM system_advisories
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         repos as (
             DELETE
                 FROM system_repo
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         packages2 as (
             DELETE
                 FROM system_package2
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         patch_systems as (
             DELETE
                 FROM system_patch
                     WHERE (rh_account_id, system_id) in (select rh_account_id, id from systems)
         ),
         deleted as (
             DELETE
                 FROM system_inventory
                     WHERE (rh_account_id, id) in (select rh_account_id, id from systems)
                     RETURNING id
         )
    SELECT count(*)
    FROM deleted
    INTO tmp_cnt;

    RETURN tmp_cnt;
END
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION delete_culled_systems(delete_limit INTEGER)
    RETURNS INTEGER
AS
$fun$
DECLARE
    ids UUID[];
BEGIN
    ids := ARRAY(
            SELECT inventory_id
            FROM system_inventory
            WHERE culled_timestamp < now()
            ORDER BY id
            LIMIT delete_limit
        );
    return delete_systems(ids);
END;
$fun$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION mark_stale_systems(mark_limit integer)
    RETURNS INTEGER
AS
$fun$
DECLARE
    marked integer;
BEGIN
    WITH ids AS (
        SELECT rh_account_id, id, stale_warning_timestamp < now() as expired
        FROM system_inventory
        WHERE stale != (stale_warning_timestamp < now())
        ORDER BY rh_account_id, id FOR UPDATE OF system_inventory
        LIMIT mark_limit
    )
    UPDATE system_inventory si
    SET stale = ids.expired
    FROM ids
    WHERE si.rh_account_id = ids.rh_account_id
      AND si.id = ids.id;
    GET DIAGNOSTICS marked = ROW_COUNT;
    RETURN marked;
END;
$fun$ LANGUAGE plpgsql;

do $$ begin RAISE NOTICE 'Updated functions to use system_inventory'; end $$;



-- system_patch
CREATE TABLE IF NOT EXISTS system_patch
(
    system_id                            BIGINT      NOT NULL,
    rh_account_id                        INT         NOT NULL,
    last_evaluation                      TIMESTAMPTZ,
    installable_advisory_count_cache     INT         NOT NULL DEFAULT 0,
    installable_advisory_enh_count_cache INT         NOT NULL DEFAULT 0,
    installable_advisory_bug_count_cache INT         NOT NULL DEFAULT 0,
    installable_advisory_sec_count_cache INT         NOT NULL DEFAULT 0,
    packages_installed                   INT         NOT NULL DEFAULT 0,
    packages_installable                 INT         NOT NULL DEFAULT 0,
    packages_applicable                  INT         NOT NULL DEFAULT 0,
    third_party                          BOOLEAN     NOT NULL DEFAULT false,
    applicable_advisory_count_cache      INT         NOT NULL DEFAULT 0,
    applicable_advisory_enh_count_cache  INT         NOT NULL DEFAULT 0,
    applicable_advisory_bug_count_cache  INT         NOT NULL DEFAULT 0,
    applicable_advisory_sec_count_cache  INT         NOT NULL DEFAULT 0,
    template_id                          BIGINT
) PARTITION BY HASH (rh_account_id);

-- PARTITIONING
SELECT create_table_partitions('system_patch', 16,
                               $$WITH (fillfactor = '70', autovacuum_vacuum_scale_factor = '0.05')
                                 TABLESPACE pg_default$$);

-- PRIVILEGES (evaluator has write access)
GRANT SELECT, UPDATE ON system_patch TO evaluator;
GRANT SELECT, INSERT, UPDATE ON system_patch TO listener; -- insert/update because of templateID in upload evnet
GRANT SELECT, UPDATE (installable_advisory_count_cache,
              installable_advisory_enh_count_cache,
              installable_advisory_bug_count_cache,
              installable_advisory_sec_count_cache,
              applicable_advisory_count_cache,
              applicable_advisory_enh_count_cache,
              applicable_advisory_bug_count_cache,
              applicable_advisory_sec_count_cache) ON system_patch TO manager;
GRANT SELECT, UPDATE, DELETE ON system_patch to vmaas_sync; -- vmaas_sync performs system culling
SELECT grant_table_partitions('SELECT', 'system_patch', 'evaluator');
SELECT grant_table_partitions('SELECT', 'system_patch', 'listener');
SELECT grant_table_partitions('SELECT', 'system_patch', 'manager');
SELECT grant_table_partitions('SELECT', 'system_patch', 'vmaas_sync');

do $$ begin RAISE NOTICE 'Created system_patch'; end $$;

INSERT INTO system_patch SELECT
    id,
    rh_account_id,
    last_evaluation,
    installable_advisory_count_cache,
    installable_advisory_enh_count_cache,
    installable_advisory_bug_count_cache,
    installable_advisory_sec_count_cache,
    packages_installed,
    packages_installable,
    packages_applicable,
    third_party,
    applicable_advisory_count_cache,
    applicable_advisory_enh_count_cache,
    applicable_advisory_bug_count_cache,
    applicable_advisory_sec_count_cache,
    template_id
FROM system_platform sp;

do $$ begin RAISE NOTICE 'Data loaded into system_patch'; end $$;

-- CONSTRAINTS
ALTER TABLE IF EXISTS system_patch 
ADD PRIMARY KEY (rh_account_id, system_id),
ADD FOREIGN KEY (rh_account_id, template_id) REFERENCES template (rh_account_id, id),
ADD FOREIGN KEY (rh_account_id, system_id) REFERENCES system_inventory (rh_account_id, id);



-- system_platform
DROP TABLE IF EXISTS system_platform;
CREATE OR REPLACE VIEW system_platform AS SELECT
    si.id,
    si.inventory_id,
    si.rh_account_id,
    si.vmaas_json,
    si.json_checksum,
    si.last_updated,
    si.unchanged_since,
    sp.last_evaluation,
    sp.installable_advisory_count_cache,
    sp.installable_advisory_enh_count_cache,
    sp.installable_advisory_bug_count_cache,
    sp.installable_advisory_sec_count_cache,
    si.last_upload,
    si.stale_timestamp,
    si.stale_warning_timestamp,
    si.culled_timestamp,
    si.stale,
    si.display_name,
    sp.packages_installed,
    sp.packages_installable,
    si.reporter_id,
    sp.third_party,
    si.yum_updates,
    sp.applicable_advisory_count_cache,
    sp.applicable_advisory_enh_count_cache,
    sp.applicable_advisory_bug_count_cache,
    sp.applicable_advisory_sec_count_cache,
    si.satellite_managed,
    si.built_pkgcache,
    sp.packages_applicable,
    sp.template_id,
    si.yum_checksum,
    si.arch,
    si.bootc
FROM system_inventory si JOIN system_patch sp
    ON si.id = sp.system_id AND si.rh_account_id = sp.rh_account_id;

GRANT SELECT, INSERT, UPDATE, DELETE ON system_platform TO listener;
-- evaluator needs to update last_evaluation
GRANT SELECT, UPDATE ON system_platform TO evaluator;
-- manager needs to update cache and delete systems
GRANT SELECT, UPDATE, DELETE ON system_platform TO manager;
-- VMaaS sync needs to be able to perform system culling tasks
GRANT SELECT, UPDATE, DELETE ON system_platform to vmaas_sync;

do $$ begin RAISE NOTICE 'Migration 142 end'; end $$;
